# -*- coding: utf-8 -*-
"""
YOLO + (Optional) GPT-4o-mini
- ç•«æ¡†ï¼ˆå¯åˆ‡æ›ï¼‰
- å±éšªåˆ†ç´šï¼šç”¨ YOLO åµæ¸¬ç‰©ä»¶æ•¸é‡åšè¦å‰‡åˆ†ç´šï¼ˆå¯é‡ç¾ï¼‰
- è¼¸å‡ºåˆ°æ–°è³‡æ–™å¤¾ï¼ˆä¸è¦†è“‹æ—¢æœ‰æˆæœï¼‰
- ç”Ÿæˆæ–°çš„ CSVï¼ˆåŸºæ–¼åŸ CSV ç–ŠåŠ æ–°æ¬„ä½ï¼Œä¸è¦†è“‹åŸæª”ï¼‰
-  æ–°å¢ï¼šæŠŠè¼¸å‡ºç…§ç‰‡ã€Œç›¸å°è·¯å¾‘ã€ä¸€èµ·å¯«é€² CSVï¼ˆæ–¹ä¾¿ QGIS portableï¼‰
-  æ–°å¢ï¼šEmergency Level 0 æ–‡å­—é¡¯ç¤ºç¶ è‰²ï¼›Level 1/2 é¡¯ç¤ºç´…è‰²
"""

from ultralytics import YOLO
from pathlib import Path
import cv2
import pandas as pd
import json
import re
import os
from openai import OpenAI
from dotenv import load_dotenv


# ================== 0) ä½ å¯ä»¥èª¿çš„é–‹é—œ ==================
DRAW_BOXES = True      # True: YOLO ç•«æ¡†ï¼›False: ä¸ç•«æ¡†
USE_LLM = True         # True: ç”¨ GPT ç”¢ç”Ÿ warning_textï¼›False: ç”¨è¦å‰‡ç”¢ç”Ÿ warning_textï¼ˆçœéŒ¢ã€å¯é‡ç¾ï¼‰


# ================== 1) è·¯å¾‘è¨­å®šï¼ˆä¾ä½ æä¾›çš„éœ€æ±‚ï¼‰ ==================

REPORT_ROOT = Path(r"C:\Users\user\Desktop\NCKU_Master\01_MASTER01\02_SMART MACHINING SYSTEMS\Report")

MODEL_CANDIDATES = [
    REPORT_ROOT / "yolo11m.pt",
    REPORT_ROOT / "models_medium" / "yolo11m.pt",
    REPORT_ROOT / "models" / "yolo11m.pt",
]

IMAGES_DIR = Path(r"C:\Users\user\Desktop\NCKU_Master\01_MASTER01\02_SMART MACHINING SYSTEMS\Report\images_large")

SRC_CSV = Path(r"C:\Users\user\Desktop\NCKU_Master\01_MASTER01\02_SMART MACHINING SYSTEMS\Report\01_original_information\routes_large_points.csv")

OUT_IMG_DIR = Path(r"C:\Users\user\Desktop\NCKU_Master\01_MASTER01\02_SMART MACHINING SYSTEMS\Report\try_large_output")

OUT_TAB_DIR = Path(r"C:\Users\user\Desktop\NCKU_Master\01_MASTER01\02_SMART MACHINING SYSTEMS\Report\try_csv+geojson_output")
OUT_CSV = OUT_TAB_DIR / "routes_large_points_with_llm.csv"

OUT_IMG_DIR.mkdir(parents=True, exist_ok=True)
OUT_TAB_DIR.mkdir(parents=True, exist_ok=True)

if not IMAGES_DIR.exists():
    raise FileNotFoundError(f"æ‰¾ä¸åˆ°å½±åƒè³‡æ–™å¤¾ï¼š{IMAGES_DIR}")

if not SRC_CSV.exists():
    raise FileNotFoundError(f"æ‰¾ä¸åˆ°åŸå§‹ CSVï¼š{SRC_CSV}")

MODEL_PATH = None
for p in MODEL_CANDIDATES:
    if p.exists():
        MODEL_PATH = p
        break

if MODEL_PATH is None:
    raise FileNotFoundError(
        "æ‰¾ä¸åˆ° YOLO æ¬Šé‡æª” yolo11m.ptã€‚\n"
        "è«‹ç¢ºèªä»¥ä¸‹ä»»ä¸€ä½ç½®å­˜åœ¨ï¼š\n- " + "\n- ".join(str(x) for x in MODEL_CANDIDATES)
    )


# ================== 2) YOLO ==================
model = YOLO(str(MODEL_PATH))


# ================== 3) OpenAIï¼ˆå¯é¸ï¼‰==================
client = None
if USE_LLM:
    load_dotenv(str(REPORT_ROOT / ".env"))
    if not os.getenv("OPENAI_API_KEY"):
        raise RuntimeError("USE_LLM=True ä½†æ²’æœ‰è®€åˆ° OPENAI_API_KEYã€‚è«‹ç¢ºèª Report\\.env å…§æœ‰ OPENAI_API_KEY=...")

    client = OpenAI()


def _extract_json_maybe(text: str) -> dict:
    text = (text or "").strip()
    try:
        return json.loads(text)
    except Exception:
        pass

    m = re.search(r"\{.*\}", text, flags=re.DOTALL)
    if not m:
        raise ValueError(f"LLM å›å‚³ä¸æ˜¯ JSONï¼š{text[:200]}")
    return json.loads(m.group(0))


def llm_warning_text(counts: dict) -> str:
    """
    åªè¦ warning_textï¼Œä¸è¦è®“ LLM æ±ºå®š levelï¼ˆlevel æˆ‘å€‘ç”¨è¦å‰‡ï¼Œæ‰å¯é‡ç¾ï¼‰
    """
    prompt = f"""
You are a pedestrian safety assistant.

Given detected objects in a street image:
{json.dumps(counts, ensure_ascii=False)}

Task:
- Write ONE short warning sentence (<= 25 words).
- Focus on pedestrian safety.
- Output must be JSON only.

Output format:
{{
  "warning_text": "..."
}}
"""
    resp = client.chat.completions.create(
        model="gpt-4o-mini",
        temperature=0,
        messages=[{"role": "user", "content": prompt}]
    )
    raw = resp.choices[0].message.content
    data = _extract_json_maybe(raw)
    return str(data.get("warning_text", "Caution advised."))


# ================== 4) è¦å‰‡åˆ†ç´šï¼ˆä½ æå‡ºçš„æ ¸å¿ƒæƒ³æ³•ï¼‰ ==================
def rule_risk_level(counts: dict) -> int:
    """
    ä¾ä½ æœ€æ–°è¦å‰‡åšå±éšªåˆ†ç´šï¼ˆ0/1/2ï¼‰ï¼š

    Emergency Level 0:
      - car <= 1
      - (bicycle + motorcycle) <= 5

    Emergency Level 1:
      - car >= 2  OR  (bicycle + motorcycle) > 5   ï¼ˆå‘½ä¸­å…¶ä¸­ä¸€å€‹å°±ç®—ï¼‰

    Emergency Level 2:
      - (car between 2 and 4 inclusive) AND (bicycle + motorcycle) > 5
        ï¼ˆå…©å€‹æ¢ä»¶éƒ½å‘½ä¸­æ‰ç®—ï¼‰
      - OR car >= 5  ï¼ˆå–®ä¸€æ¢ä»¶å°±ç®—ï¼‰
    """
    car = counts.get("car", 0)
    bike = counts.get("bicycle", 0)
    moto = counts.get("motorcycle", 0)
    bm = bike + moto

    # ---- Level 2ï¼ˆæœ€é«˜å„ªå…ˆåˆ¤æ–·ï¼‰----
    if car >= 5:
        return 2
    if 2 <= car <= 4 and bm > 5:
        return 2

    # ---- Level 0 ----
    if car <= 1 and bm <= 5:
        return 0

    # ---- Level 1ï¼ˆå…¶é¤˜ç¬¦åˆ car>=2 æˆ– bm>5 çš„éƒ½åœ¨é€™ï¼‰----
    return 1


def rule_warning_text(level: int, counts: dict) -> str:
    car = counts.get("car", 0)
    bike = counts.get("bicycle", 0)
    moto = counts.get("motorcycle", 0)
    bm = bike + moto

    if level == 2:
        return f"High risk: {car} cars and {bm} bicycles/motorcycles nearby. Walk carefully."
    if level == 1:
        return f"Moderate risk: traffic present (cars={car}, bicycles/motorcycles={bm}). Stay alert."
    return f"Low risk: limited traffic (cars={car}, bicycles/motorcycles={bm})."


# ================== âœ… æ–‡å­—é¡è‰²ï¼šLevel 0 ç¶ è‰²ï¼›Level 1/2 ç´…è‰² ==================
def _level_color(level: int):
    """
    OpenCV color is BGR:
    - Level 0 -> green
    - Level 1/2 -> red
    """
    if level == 0:
        return (0, 255, 0)   # ç¶ è‰²
    return (0, 0, 255)       # ç´…è‰²


def _put_wrapped_text(img, text, x, y, max_chars=52, font_scale=0.8, thickness=2, line_gap=32, color=(0, 0, 255)):
    """
    OpenCV putText ä¸æœƒè‡ªå‹•æ›è¡Œï¼šç°¡å–®æŒ‰å­—æ•¸åˆ†è¡Œ
    """
    lines = []
    t = (text or "").strip()
    while len(t) > max_chars:
        lines.append(t[:max_chars])
        t = t[max_chars:]
    if t:
        lines.append(t)

    for i, line in enumerate(lines):
        cv2.putText(
            img,
            line,
            (x, y + i * line_gap),
            cv2.FONT_HERSHEY_SIMPLEX,
            font_scale,
            color,               # âœ… ä½¿ç”¨å‚³å…¥é¡è‰²
            thickness,
            cv2.LINE_AA
        )


# ================== 5) ä¸»æµç¨‹ ==================
results = model(source=str(IMAGES_DIR), stream=True)

det_rows = []

for r in results:
    r_path = Path(getattr(r, "path", ""))
    img_filename = r_path.name if r_path.name else "unknown.jpg"

    # âœ… é€™è£¡æ±ºå®šã€Œè¦ä¸è¦ç•«æ¡†ã€
    if DRAW_BOXES:
        img = r.plot()          # æœ‰æ¡†ã€æœ‰label
    else:
        img = r.orig_img.copy() # åŸåœ–ã€ä¸ç•«æ¡†

    # ---------- çµ±è¨ˆ YOLO ç‰©ä»¶ ----------
    counts = {}
    if r.boxes is not None and r.boxes.cls is not None and len(r.boxes.cls) > 0:
        cls_ids = r.boxes.cls.cpu().numpy().astype(int)
        for cid in cls_ids:
            label = model.names[int(cid)]
            counts[label] = counts.get(label, 0) + 1

    det_summary = ", ".join([f"{v} {k}" for k, v in counts.items()])

    # ---------- ç”¨è¦å‰‡ç®— level ----------
    level = rule_risk_level(counts)

    # ---------- warning_textï¼šå¯é¸ LLM or è¦å‰‡ ----------
    if USE_LLM:
        try:
            warning = llm_warning_text(counts) if counts else "No immediate hazards detected."
        except Exception as e:
            warning = f"LLM fallback (error): {e}"
    else:
        warning = rule_warning_text(level, counts)

    # ---------- ç–ŠåŠ æ–‡å­—ï¼ˆLevel0 ç¶ è‰²ï¼Œå…¶å®ƒç´…è‰²ï¼‰ ----------
    h, w, _ = img.shape
    y0 = max(40, h - 130)

    color = _level_color(level)

    cv2.putText(
        img,
        f"Emergency level: {level}",
        (30, y0),
        cv2.FONT_HERSHEY_SIMPLEX,
        1.0,
        color,  # âœ… ä¾ level æ”¹é¡è‰²
        2,
        cv2.LINE_AA
    )
    _put_wrapped_text(img, warning, 30, y0 + 40, color=color)  # âœ… warning åŒè‰²

    # ---------- å­˜åœ– ----------
    out_img_name = f"{Path(img_filename).stem}_lvl{level}.jpg"
    out_path = OUT_IMG_DIR / out_img_name
    cv2.imwrite(str(out_path), img)

    # âœ… æ–°å¢ï¼šç®—ã€Œç›¸å°æ–¼ OUT_TAB_DIRã€çš„ç›¸å°è·¯å¾‘ï¼Œçµ¦ QGIS ç”¨
    det_img_relpath = os.path.relpath(out_path, OUT_TAB_DIR)
    det_img_relpath = det_img_relpath.replace("\\", "/")  # çµ±ä¸€æˆ '/'ï¼ˆè·¨å¹³å°æ›´å¥½ï¼‰

    det_rows.append({
        "img_file": img_filename,
        "det_img_file": str(out_path),        # çµ•å°è·¯å¾‘ï¼ˆä¿ç•™ï¼Œæ–¹ä¾¿ debugï¼‰
        "det_img_relpath": det_img_relpath,   # âœ… ç›¸å°è·¯å¾‘ï¼ˆçµ¦ QGIS portableï¼‰
        "det_summary": det_summary,
        "risk_level": level,
        "warning_text": warning
    })


# ================== 6) åˆä½µ CSVï¼ˆä¸è¦†è“‹åŸæª”ï¼‰ ==================
df_src = pd.read_csv(SRC_CSV)
df_det = pd.DataFrame(det_rows)

# è‡ªå‹•æ‰¾å½±åƒæ¬„ä½ mergeï¼ˆè·Ÿä½ åŸæœ¬é‚£ä»½ä¸€è‡´ï¼‰
candidate_cols = []
for c in df_src.columns:
    cl = c.lower()
    if any(k in cl for k in ["img", "image", "file", "filename", "path"]):
        candidate_cols.append(c)

merge_col = None
for c in candidate_cols:
    if c.lower() == "img_file":
        merge_col = c
        break
if merge_col is None and candidate_cols:
    merge_col = candidate_cols[0]

if merge_col is not None:
    df_src["_img_key_"] = df_src[merge_col].astype(str).apply(lambda x: Path(x).name)
    df_det["_img_key_"] = df_det["img_file"].astype(str)

    df_out = df_src.merge(
        df_det.drop(columns=["img_file"]),
        left_on="_img_key_",
        right_on="_img_key_",
        how="left"
    ).drop(columns=["_img_key_"])
else:
    df_out = df_src.copy()
    n = min(len(df_out), len(df_det))
    df_out.loc[:n-1, "det_img_file"] = df_det.loc[:n-1, "det_img_file"].values
    df_out.loc[:n-1, "det_img_relpath"] = df_det.loc[:n-1, "det_img_relpath"].values
    df_out.loc[:n-1, "det_summary"]  = df_det.loc[:n-1, "det_summary"].values
    df_out.loc[:n-1, "risk_level"]   = df_det.loc[:n-1, "risk_level"].values
    df_out.loc[:n-1, "warning_text"] = df_det.loc[:n-1, "warning_text"].values

df_out.to_csv(OUT_CSV, index=False, encoding="utf-8-sig")

print("âœ… å®Œæˆï¼šYOLO + è¦å‰‡åˆ†ç´š + (å¯é¸ LLM æ–‡å­—) + ç›¸å°è·¯å¾‘ + Level0 ç¶ å­—")
print("ğŸ–¼ï¸ è¼¸å‡ºå½±åƒè³‡æ–™å¤¾ï¼š", OUT_IMG_DIR)
print("ğŸ“„ è¼¸å‡º CSVï¼š", OUT_CSV)
print("ğŸ§  YOLO modelï¼š", MODEL_PATH)
print("ğŸ“· ä¾†æºå½±åƒè³‡æ–™å¤¾ï¼š", IMAGES_DIR)
print("âš™ï¸ DRAW_BOXES =", DRAW_BOXES, "| USE_LLM =", USE_LLM)
